(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{381:function(t,v,_){"use strict";_.r(v);var a=_(45),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"涂鸦智能凉经"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#涂鸦智能凉经"}},[t._v("#")]),t._v(" 涂鸦智能凉经")]),t._v(" "),_("h2",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),_("p",[t._v("定义：有权访问另一个函数作用域中变量的函数")]),t._v(" "),_("p",[t._v("用处：1.读取函数内部的变量。")]),t._v(" "),_("p",[t._v("​             2.这些变量始终保存在内存中，不会在外层函数调用后被自动清除")]),t._v(" "),_("p",[t._v("优点：")]),t._v(" "),_("ol",[_("li",[t._v("变量长期驻扎在内存中")]),t._v(" "),_("li",[t._v("避免了全局变量的污染。")]),t._v(" "),_("li",[t._v("私有成员的存在")])]),t._v(" "),_("p",[t._v("特性：")]),t._v(" "),_("ol",[_("li",[t._v("函数套函数")]),t._v(" "),_("li",[t._v("内部函数可以直接使用外部函数对的雨布变量或参数。")]),t._v(" "),_("li",[t._v("变量或参数不会被垃圾回收机制回收")])]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("p",[t._v("常驻内存 会增大内存的使用量，容易造成内存泄漏")]),t._v(" "),_("ol",[_("li",[t._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用，会造成网页性能问题，在IE中可能会导致内存泄漏。解决方法，在退出含少数之前，将不使用的局部变量全部删除。")])]),t._v(" "),_("h2",{attrs:{id:"computed-和-watch"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch"}},[t._v("#")]),t._v(" computed 和 watch")]),t._v(" "),_("h3",{attrs:{id:"computed"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),_("p",[t._v("计算属性：依赖其他属性，有缓存，只有依赖属性发生改变，下一次获取computed的值才会重新计算")]),t._v(" "),_("p",[t._v("场景：当我们需要进行数据计算，并且依赖于其他数据时，有缓存，避免每次获取值都要重复计算")]),t._v(" "),_("h3",{attrs:{id:"watch"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" Watch")]),t._v(" "),_("p",[t._v("侦听器：起到观察作用，当监听的数据变化时都会执行回调进行后续操作，无缓存性")]),t._v(" "),_("p",[t._v("场景：数据变化时执行异步或开销较大的操作时，使用watch可以允许我们执行异步操作。")]),t._v(" "),_("h2",{attrs:{id:"proxy"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[t._v("#")]),t._v(" Proxy")]),t._v(" "),_("ul",[_("li",[t._v("Proxy可以直接监听对象而非属性")]),t._v(" "),_("li",[t._v("Proxy可以直接劫持整个对象，")]),t._v(" "),_("li",[t._v("Proxy返回一个新对象，我们可以只操作新的对象达到目的；Object.definedProperty只能遍历对象属性进行修改")]),t._v(" "),_("li",[t._v("Proxy具有更多的拦截方法，如apply,ownKeys,has等")]),t._v(" "),_("li",[t._v("存在兼容性问题")])]),t._v(" "),_("h2",{attrs:{id:"bfc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[t._v("#")]),t._v(" BFC")]),t._v(" "),_("p",[t._v("块级格式上下文，里面的元素和外部的元素不会相互影响\n作用：清除浮动，避免垂直外边距的重叠，实现自适应布局（如：两栏布局）")]),t._v(" "),_("p",[t._v("形成条件")]),t._v(" "),_("ol",[_("li",[t._v("浮动元素float除none以外的值")]),t._v(" "),_("li",[t._v("position:absolute,fixed")]),t._v(" "),_("li",[t._v("display:inline-blocks,table-cells,")]),t._v(" "),_("li",[t._v("overflow除了visible以外（hidden,auto,scroll\n）")])]),t._v(" "),_("h2",{attrs:{id:"模块化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),_("p",[t._v("require:node 和 es6都支持引入\nexport/import: 只有es6支持\nexprots/module.exports 只有node支持导出")]),t._v(" "),_("p",[t._v("node的遵循commonJS")]),t._v(" "),_("p",[t._v("import是异步加载，编译时加载，必须\n放在开头，不会将整个模块运行后赋值给某个变量\nrequire是同步加载，运行时加载模块")])])}),[],!1,null,null,null);v.default=e.exports}}]);