(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{380:function(t,v,_){"use strict";_.r(v);var e=_(45),p=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数新一面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数新一面"}},[t._v("#")]),t._v(" 数新一面")]),t._v(" "),_("p",[t._v("1.数据类型")]),t._v(" "),_("p",[t._v("2.判断类型的方法")]),t._v(" "),_("p",[t._v("typeof    ,instanceof,   object.prototype.tostring.call()  constructor  Object.prototype.isPrototypeOf")]),t._v(" "),_("p",[t._v("3.typeof(null) 为什么为object")]),t._v(" "),_("p",[t._v("这是js存在很久的bug。在js的最初版本使用的是32为的系统，为了性能考虑使用低位存储变量的类型信息，000代表对象，而null 表示全为空，所以判断成object.")]),t._v(" "),_("p",[t._v("可以使用Object.prototype.toString.call(null)   ==> [object,null]")]),t._v(" "),_("p",[t._v("4.深浅拷贝的区别，实现深拷贝的方法")]),t._v(" "),_("p",[t._v("深浅拷贝的区别主要表现在对于引用类型的拷贝，浅拷贝只拷贝指向某个对象的指针快，新旧对象还是共享同一块内存地址，其中一个对象改变了这个内存地址会影响到另一个对象。而深拷贝是是完全拷贝，两个对象不会相互影响。")]),t._v(" "),_("p",[t._v("方法：JSON.parse(JSON.stringify),递归实现")]),t._v(" "),_("p",[t._v("5.es6 新增的")]),t._v(" "),_("p",[t._v("6.promise")]),t._v(" "),_("p",[t._v("7.async  await跟promise的区别与普通函数的区别")]),t._v(" "),_("p",[t._v("8.箭头函数")]),t._v(" "),_("p",[t._v("8.三次握手四次挥手")]),t._v(" "),_("p",[t._v("9.vue响应式原理")]),t._v(" "),_("p",[t._v("10.koa的洋葱模型")]),t._v(" "),_("p",[t._v("11.hooks解决了函数组件的什么问题")]),t._v(" "),_("p",[t._v("12.react-fiber")]),t._v(" "),_("p",[t._v("13函数组件和类组件的区别")]),t._v(" "),_("p",[t._v("14.学习中遇到最难的问题")])])}),[],!1,null,null,null);v.default=p.exports}}]);