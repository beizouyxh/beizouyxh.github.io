(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{366:function(a,e,t){"use strict";t.r(e);var s=t(45),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),t("p",[t("strong",[a._v("浏览器缓存")]),a._v(" 是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。")]),a._v(" "),t("p",[a._v("但也不是说缓存没有缺点，如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。")]),a._v(" "),t("p",[a._v("缓存的优点：")]),a._v(" "),t("ul",[t("li",[a._v("减少了冗余的数据传输，节省网费")]),a._v(" "),t("li",[a._v("减少服务器的负担，提升网站性能")]),a._v(" "),t("li",[a._v("加快了客户端加载网页的速度")])]),a._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),t("p",[t("strong",[a._v("如果资源没过期，就取缓存，如果过期了，则请求服务器。")])]),a._v(" "),t("p",[a._v("强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间")]),a._v(" "),t("p",[t("code",[a._v("HTTP1.0")]),a._v("时，使用的是 "),t("strong",[a._v("Expires")]),a._v("，"),t("code",[a._v("HTTP1.1")]),a._v("时，使用的是 "),t("strong",[a._v("Cache-Control")])]),a._v(" "),t("h4",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),t("p",[t("code",[a._v("Expires")]),a._v(" 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间内可以直接从缓存里面获取数据，无需再次请求\n它的值为一个绝对时间的GMT格式的时间字符串，比如：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Expires"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Mon"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" Sept "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2020")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("23")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("59")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("59")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GMT")]),a._v("\n")])])]),t("p",[a._v("表示资源在 "),t("code",[a._v("2020年9月22日23:59:59")]),a._v(" 过期失效，过期了就要向服务器端发请求\n这种方式有一个明显的缺点，由于失效时间是一个绝对时间，"),t("code",[a._v("服务器的时间和浏览器的时间可能不一致")]),a._v("，所以服务器返回的这个过期时间可能就是不准确的，所以在 HTTP1.1 版本中被抛弃了")]),a._v(" "),t("h4",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),t("p",[a._v("在 HTTP1.1 中采取了 "),t("code",[a._v("Cache-Control")]),a._v("\n它和 "),t("code",[a._v("Expires")]),a._v(" "),t("strong",[a._v("本质的不同是它没有采用具体的过期时间点这个方式")]),a._v("，而是采用过期时长来控制缓存，对应的字段是 "),t("code",[a._v("max-age")]),a._v("，它是一个相对时间，比如：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Cache"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("Control"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("max"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("age"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3600")]),a._v("\n")])])]),t("p",[a._v("代表资源的有效期是 3600 秒，响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存\n常用的配合设置的值：")]),a._v(" "),t("ol",[t("li",[a._v("public：可以被所有的用户缓存，包括客户端和 CDN 等中间代理服务器(因为一个请求可能要经过不同的代理服务器才到达目标服务器)")]),a._v(" "),t("li",[a._v("private：只能被浏览器缓存，不允许 CDN 等中间代理服务器缓存")]),a._v(" "),t("li",[a._v("no-cache：不使用本地缓存，跳过当前的强缓存，直接进入 "),t("code",[a._v("协商缓存阶段")])]),a._v(" "),t("li",[a._v("no-store：不强缓存，也不协商缓存，基本不用，缓存越多才越好呢")]),a._v(" "),t("li",[a._v("s-maxage：和 "),t("code",[a._v("max-age")]),a._v(" 比较像，但是区别在于 "),t("code",[a._v("s-maxage")]),a._v(" 是针对代理服务器的缓存时间\n"),t("code",[a._v("当 Expires 和 Cache-Control 同时存在的时候，Cache-Control 会有效考虑")])])]),a._v(" "),t("h4",{attrs:{id:"强缓存流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存流程"}},[a._v("#")]),a._v(" 强缓存流程")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/18/168602e5bb5e5b7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/18/168603039eeb6f12?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),a._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),t("p",[a._v("触发条件：")]),a._v(" "),t("ol",[t("li",[a._v("Cache-Control 的值为 no-cache （不强缓存）")]),a._v(" "),t("li",[a._v("或者 max-age 过期了 （强缓存，但总有过期的时候）")])]),a._v(" "),t("p",[a._v("也就是说，不管怎样，都可能最后要进行协商缓存（no-store除外）")]),a._v(" "),t("p",[a._v("需要请求头中添加tag，服务器根据tag来判断是否使用缓存，所以被称为协商缓存。tag分为两种Last-Modified和ETag")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("Last-Modified")])])]),a._v(" "),t("p",[a._v("最后修改时间。在第一次请求完毕后，服务器给浏览器返回的响应头里会带有Last-Modified，浏览器在下一次请求的时候会携带If-Modified-Since，表示服务器资源最后修改时间，最后进行相应的操作。否则返回304，但只能以秒为单位，所以不够精准(不在意这几秒的差距也OK)")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("ETag")])])]),a._v(" "),t("p",[a._v("ETag是给当前的文件资源添加唯一的文件标识，只要内容有改动就值就会变。服务器会将其加在响应头中，浏览器会在下次请求的时候将其作为If-None-Match字段的内容发送给服务器。服务器根据值做不同的操作")]),a._v(" "),t("ul",[t("li",[a._v("两者对比：")])]),a._v(" "),t("p",[a._v("ETag优先级比Last-Modified高，因为它可以精确的判断是否需要更新。虽然性能不如Last-Modified")]),a._v(" "),t("h2",{attrs:{id:"缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),t("p",[a._v("强缓存命中或者协商缓存阶段服务器换回 304 的时候，直接从缓存中获取资源\n浏览器中的缓存位置一共有四种，按优先级从高到低依次为：")]),a._v(" "),t("ol",[t("li",[a._v("Service Worker")]),a._v(" "),t("li",[a._v("Memory Cache")]),a._v(" "),t("li",[a._v("Disk Cache")]),a._v(" "),t("li",[a._v("Push Cache")])]),a._v(" "),t("h4",{attrs:{id:"service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),t("p",[t("code",[a._v("Service Worker")]),a._v(" 借鉴了 Web Worker 的思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助完成很多有用的功能，比如"),t("code",[a._v("离线缓存")]),a._v("、"),t("code",[a._v("消息推送")]),a._v("和"),t("code",[a._v("网络代理")]),a._v("等功能。其中的"),t("code",[a._v("离线缓存")]),a._v("就是 Service Worker Cache")]),a._v(" "),t("h4",{attrs:{id:"memory-cache-和-disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache-和-disk-cache"}},[a._v("#")]),a._v(" Memory Cache 和 Disk Cache")]),a._v(" "),t("p",[t("code",[a._v("Memory Cache")]),a._v(" 指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了\n"),t("code",[a._v("Disk Cache")]),a._v(" 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长")]),a._v(" "),t("ol",[t("li",[a._v("比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存")]),a._v(" "),t("li",[a._v("内存使用率比较高的时候，文件优先进入磁盘")])]),a._v(" "),t("h4",{attrs:{id:"push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),t("p",[a._v("即推送缓存，这是浏览器缓存的最后一道防线，是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛")]),a._v(" "),t("h2",{attrs:{id:"强缓存和协商缓存的比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协商缓存的比较"}},[a._v("#")]),a._v(" 强缓存和协商缓存的比较")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/21/1686c02dc305d66c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("- 如果强缓存可用，直接使用  \n- 如果强缓存不可能，进入协商缓存阶段，发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 字段检查判断是否资源是否更新  \n  + 如果资源更新，返回资源和 200 状态码  \n  + 如果资源未更新，返回 304，告诉浏览器直接从缓存获取资源  \n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);