<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 之作用域和闭包 | 北走的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.957315a2.css" as="style"><link rel="preload" href="/assets/js/app.8852ea87.js" as="script"><link rel="preload" href="/assets/js/2.4650da32.js" as="script"><link rel="preload" href="/assets/js/27.b68349d0.js" as="script"><link rel="prefetch" href="/assets/js/10.0c944c6a.js"><link rel="prefetch" href="/assets/js/11.e516ee82.js"><link rel="prefetch" href="/assets/js/12.6b960f53.js"><link rel="prefetch" href="/assets/js/13.56e593e5.js"><link rel="prefetch" href="/assets/js/14.94bff529.js"><link rel="prefetch" href="/assets/js/15.d5a82768.js"><link rel="prefetch" href="/assets/js/16.b2935eef.js"><link rel="prefetch" href="/assets/js/17.f0292fb1.js"><link rel="prefetch" href="/assets/js/18.0dbd9c93.js"><link rel="prefetch" href="/assets/js/19.9f0a8a54.js"><link rel="prefetch" href="/assets/js/20.230c81a5.js"><link rel="prefetch" href="/assets/js/21.32025ae8.js"><link rel="prefetch" href="/assets/js/22.49c038f7.js"><link rel="prefetch" href="/assets/js/23.4750946a.js"><link rel="prefetch" href="/assets/js/24.0ab28450.js"><link rel="prefetch" href="/assets/js/25.29bc4bae.js"><link rel="prefetch" href="/assets/js/26.3909a8c5.js"><link rel="prefetch" href="/assets/js/28.4fc2490b.js"><link rel="prefetch" href="/assets/js/29.a7e83f30.js"><link rel="prefetch" href="/assets/js/3.cc6640f5.js"><link rel="prefetch" href="/assets/js/30.464a820b.js"><link rel="prefetch" href="/assets/js/31.e676e3db.js"><link rel="prefetch" href="/assets/js/32.3d1d70b0.js"><link rel="prefetch" href="/assets/js/33.44ea0f45.js"><link rel="prefetch" href="/assets/js/34.700259bd.js"><link rel="prefetch" href="/assets/js/35.87bbffed.js"><link rel="prefetch" href="/assets/js/36.d6bf86af.js"><link rel="prefetch" href="/assets/js/37.95e5afb8.js"><link rel="prefetch" href="/assets/js/38.c491b528.js"><link rel="prefetch" href="/assets/js/4.d6d5ac09.js"><link rel="prefetch" href="/assets/js/5.7478c3f9.js"><link rel="prefetch" href="/assets/js/6.3f5e8971.js"><link rel="prefetch" href="/assets/js/7.f5d551b7.js"><link rel="prefetch" href="/assets/js/8.112e35f8.js"><link rel="prefetch" href="/assets/js/9.de436588.js">
    <link rel="stylesheet" href="/assets/css/0.styles.957315a2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="北走的博客" class="logo"> <span class="site-name can-hide">北走的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/" class="nav-link router-link-active">
  个人学习
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/beizouyxh" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/" class="nav-link router-link-active">
  个人学习
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/beizouyxh" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/CSS/center.html" class="sidebar-link">水平垂直居中</a></li><li><a href="/study/CSS/3len.html" class="sidebar-link">CSS 之三栏布局</a></li><li><a href="/study/CSS/position.html" class="sidebar-link">Position</a></li><li><a href="/study/CSS/2len.html" class="sidebar-link">两栏布局</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/javaScript/article1.html" class="sidebar-link">JavaScript 之数据类型</a></li><li><a href="/study/javaScript/article2.html" aria-current="page" class="active sidebar-link">js 之作用域和闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/javaScript/article2.html#闭包" class="sidebar-link">闭包</a></li></ul></li><li><a href="/study/javaScript/article3.html" class="sidebar-link">Javascript 异步</a></li><li><a href="/study/javaScript/article4.html" class="sidebar-link">JS中this的指向</a></li><li><a href="/study/javaScript/flatten.html" class="sidebar-link">数组扁平化</a></li><li><a href="/study/javaScript/extends.html" class="sidebar-link">JS 之继承</a></li><li><a href="/study/javaScript/promise.html" class="sidebar-link">Promise</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>react系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/react/article1.html" class="sidebar-link">React 与 Vue 的生命周期</a></li><li><a href="/study/react/article2.html" class="sidebar-link">React知识点</a></li><li><a href="/study/react/article3.html" class="sidebar-link">React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/Vue/acticle1.html" class="sidebar-link">Vue 知识点</a></li><li><a href="/study/Vue/acticle2.html" class="sidebar-link">React 与 Vue</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/Browser/article1.html" class="sidebar-link">浏览器工作原理之渲染流程</a></li><li><a href="/study/Browser/article2.html" class="sidebar-link">前端之性能优化方法</a></li><li><a href="/study/Browser/article3.html" class="sidebar-link">WebSocket</a></li><li><a href="/study/Browser/article4.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/study/Browser/article5.html" class="sidebar-link">跨域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Git</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/Git/git.html" class="sidebar-link">git</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面经系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/interview/360.html" class="sidebar-link">360面试题</a></li><li><a href="/study/interview/liang.html" class="sidebar-link">凉经</a></li><li><a href="/study/interview/tuya.html" class="sidebar-link">涂鸦智能凉经</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>WebPack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/Webpack/article1.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/network/article1.html" class="sidebar-link">Cookie,Session,Token, JWT</a></li><li><a href="/study/network/article2.html" class="sidebar-link">TCP 的三次握手和四次挥手</a></li><li><a href="/study/network/http.html" class="sidebar-link">HTTP 知识点</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-之作用域和闭包"><a href="#js-之作用域和闭包" class="header-anchor">#</a> js 之作用域和闭包</h1> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p> <h4 id="全局作用域"><a href="#全局作用域" class="header-anchor">#</a> 全局作用域</h4> <p>在代码中任何地方都能访问到的对象拥有全局作用域，，一般来说以下三种情形拥有全局作用域：</p> <p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> global <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>     <span class="token comment">// 显式声明一个全局变量</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 显式声明一个局部变量</span>
    <span class="token keyword">return</span> global<span class="token punctuation">;</span>         <span class="token comment">// 返回全局变量的值</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// &quot;global&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;global&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// error: local is not defined.`</span>
</code></pre></div><p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 显式声明一个局部变量</span>
    global <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 隐式声明一个全局变量(不好的写法)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// &quot;global&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// error: local is not defined.`</span>
</code></pre></div><p>上面代码中，变量 <code>global</code> 未用 <code>var</code> 关键字定义就直接赋值，所以隐式的创建了全局变量 <code>global</code>，但这种写法容易造成误解，应尽量避免这种写法。</p> <p>3.所有 <code>window</code> 对象的属性拥有全局作用域</p> <p>一般情况下，<code>window</code> 对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p> <h4 id="局部作用域"><a href="#局部作用域" class="header-anchor">#</a> 局部作用域</h4> <p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 显式声明一个局部变量</span>
    <span class="token keyword">return</span> local<span class="token punctuation">;</span>         <span class="token comment">// 返回全局变量的值</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;local&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// error: local is not defined.`</span>
</code></pre></div><p>上面代码中，在函数体内定义了变量 <code>local</code>，在函数体内是可以访问了，在函数外访问就报错了。</p> <h3 id="全局和局部作用域的关系"><a href="#全局和局部作用域的关系" class="header-anchor">#</a> 全局和局部作用域的关系</h3> <p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// 声明一个全局变量</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 声明一个同名的局部变量</span>
    <span class="token keyword">return</span> scope<span class="token punctuation">;</span>          <span class="token comment">// 返回局部变量的值，而不是全局变量的值</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;local&quot;`</span>
</code></pre></div><p>尽管在全局作用域编写代码时可以不写 <code>var</code> 语句，但声明局部变量时则必须使用 <code>var</code> 语句。思考一下如果不这样做会怎样：</p> <div class="language-js extra-class"><pre class="language-js"><code>scope <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>           <span class="token comment">// 声明一个全局变量，甚至不用 var 来声明</span>
<span class="token keyword">function</span> <span class="token function">checkscope2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    scope <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>        <span class="token comment">// 糟糕！我们刚修改了全局变量</span>
    myscope <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// 这里显式地声明了一个新的全局变量</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>scope<span class="token punctuation">,</span> myscope<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 返回两个值</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkscope2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;local&quot;, &quot;local&quot;]，产生了副作用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// &quot;local&quot;，全局变量修改了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myscope<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// &quot;local&quot;，全局命名空间搞乱了`</span>
</code></pre></div><p>函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;global scope&quot;</span><span class="token punctuation">;</span>         <span class="token comment">// 全局变量</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;local scope&quot;</span><span class="token punctuation">;</span>      <span class="token comment">//局部变量 </span>
    <span class="token keyword">function</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;nested scope&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 嵌套作用域内的局部变量</span>
        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>               <span class="token comment">// 返回当前作用域内的值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// &quot;nested scope&quot;`</span>
</code></pre></div><h3 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="header-anchor">#</a> 函数作用域和声明提前</h3> <p>在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p> <p>在如下所示的代码中，在不同位置定义了变量 <code>i</code>、<code>j</code> 和 <code>k</code>，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// i在整个函数体内均是有定义的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> o <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// j在函数体内是有定义的，不仅仅是在这个代码段内</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// k在函数体内是有定义的，不仅仅是在循环内</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出数字0~9</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// k已经定义了，输出10</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j已经定义了，但可能没有初始化</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出&quot;undefined&quot;，而不是&quot;global&quot;</span>
    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出&quot;local&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可能会误以为函数中的第一行会输出 <code>&quot;global&quot;</code>，因为代码还没有执行到 <code>var</code> 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 <code>var</code> 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> scope<span class="token punctuation">;</span>          <span class="token comment">// 在函数顶部声明了局部变量</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 变量存在，但其值是&quot;undefined&quot;</span>
    scope <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// 这里将其初始化并赋值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里它具有了我们所期望的值</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。</p> <h3 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h3> <p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 <code>arguments</code> 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p> <p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">===</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        color <span class="token operator">=</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//undefined` </span>
</code></pre></div><p>在这个简单的例子中，函数 <code>changeColor()</code> 的作用域链包含两个对象：它自己的变量对象（其中定义着 <code>arguments</code> 对象）和全局环境的变量对象。可以在函数内部访问变量 <code>color</code>，就是因为可以在这个作用域链中找到它。</p> <p>此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> anotherColor <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> tempColor <span class="token operator">=</span> anotherColor<span class="token punctuation">;</span>
        anotherColor <span class="token operator">=</span> color<span class="token punctuation">;</span>
        color <span class="token operator">=</span> tempColor<span class="token punctuation">;</span>
    
        <span class="token comment">// 这里可以访问color、anotherColor和tempColor</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span>
    <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里只能访问color</span>
<span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

</code></pre></div><p>以上代码共涉及3个执行环境：全局环境、<code>changeColor()</code> 的局部环境和 <code>swapColors()</code> 的局部环境。全局环境中有一个变量 <code>color</code> 和一个函数 <code>changeColor()</code>。<code>changeColor()</code> 的局部环境中有一个名为 <code>anotherColor</code> 的变量和一个名为 <code>swapColors()</code> 的函数，但它也可以访问全局环境中的变量 <code>color</code>。<code>swapColors()</code> 的局部环境中有一个变量 <code>tempColor</code>，该变量只能在这个环境中访问到。无论全局环境还是 <code>changeColor()</code> 的局部环境都无权访问 <code>tempColor</code>。然而，在 <code>swapColors()</code> 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> <strong>闭包</strong></h2> <p><strong>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</strong></p> <p>闭包的用途</p> <p>闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　
    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">function</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> fun2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　
<span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>在这段代码中result<code>实际上就是函数</code>fun2<code>。它一共运行了两次，第一次的值是</code>1<code>，第二次的值是</code>2<code>。这证明了，函数</code>fun<code>中的局部变量</code>n<code>一直保存在内存中，并没有在</code>fun` 调用后被自动清除。</p> <p>为什么会这样呢？原因就在于 <code>fun</code> 是 <code>fun2</code> 的父函数，而 <code>fun2</code> 被赋给了一个全局变量，这导致 <code>fun2</code> 始终在内存中，而 <code>fun2</code> 的存在依赖于 <code>fun</code>，因此 <code>fun</code> 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p> <p>这段代码中另一个值得注意的地方，就是 <code>add = function() { n += 1 }</code> 这一行。首先，变量 <code>add</code> 前面没有使用 <code>var</code> 关键字，因此 <code>add</code> 是一个全局变量，而不是局部变量。其次，<code>add</code> 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 <code>fun2</code> 处于同一作用域，所以 <code>add</code> 相当于是一个 <code>setter</code>，可以在函数外部对函数内部的局部变量进行操作。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/7/2020, 5:21:00 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study/javaScript/article1.html" class="prev">
        JavaScript 之数据类型
      </a></span> <span class="next"><a href="/study/javaScript/article3.html">
        Javascript 异步
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8852ea87.js" defer></script><script src="/assets/js/2.4650da32.js" defer></script><script src="/assets/js/27.b68349d0.js" defer></script>
  </body>
</html>
